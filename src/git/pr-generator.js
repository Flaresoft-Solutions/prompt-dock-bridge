import { exec } from 'child_process';
import { promisify } from 'util';
import simpleGit from 'simple-git';
import { logger } from '../utils/logger.js';

const execAsync = promisify(exec);

export async function generatePullRequest(workdir, options = {}) {
  try {
    const git = simpleGit(workdir);
    const status = await git.status();

    if (!status.isClean()) {
      if (options.autoCommit) {
        await git.add('.');
        await git.commit(options.commitMessage || 'AI-generated changes via Prompt Dock Bridge');
      } else {
        throw new Error('Uncommitted changes detected. Please commit first.');
      }
    }

    const currentBranch = (await git.branch()).current;
    const remotes = await git.getRemotes(true);

    if (remotes.length === 0) {
      throw new Error('No git remote configured');
    }

    const remote = remotes[0];
    const remoteUrl = remote.refs.fetch || remote.refs.push;

    await git.push('origin', currentBranch, ['--set-upstream']);

    const prTitle = options.title || generatePRTitle(options.prompt);
    const prBody = generatePRBody(options);

    let prUrl = null;

    if (remoteUrl.includes('github.com')) {
      prUrl = await createGitHubPR(workdir, prTitle, prBody, currentBranch, options.baseBranch);
    } else if (remoteUrl.includes('gitlab.com')) {
      prUrl = await createGitLabMR(workdir, prTitle, prBody, currentBranch, options.baseBranch);
    } else if (remoteUrl.includes('bitbucket.org')) {
      prUrl = await createBitbucketPR(workdir, prTitle, prBody, currentBranch, options.baseBranch);
    } else {
      logger.warn('Unsupported git provider. PR must be created manually.');
      return {
        success: false,
        message: 'Unsupported git provider',
        branch: currentBranch
      };
    }

    return {
      success: true,
      url: prUrl,
      branch: currentBranch,
      title: prTitle
    };
  } catch (error) {
    logger.error('Failed to generate pull request:', error);
    throw error;
  }
}

function generatePRTitle(prompt) {
  if (!prompt) return 'AI-generated changes';

  const title = prompt.split('\n')[0].substring(0, 60);
  return title.endsWith('.') ? title.slice(0, -1) : title;
}

function generatePRBody(options) {
  const sections = [];

  sections.push('## Summary');
  if (options.prompt) {
    sections.push(`**Prompt:** ${options.prompt}`);
  }
  if (options.plan) {
    sections.push('\n## Plan\n```\n' + options.plan + '\n```');
  }

  sections.push('\n## Changes');
  if (options.modifiedFiles && options.modifiedFiles.length > 0) {
    sections.push('**Modified files:**');
    options.modifiedFiles.forEach(file => {
      sections.push(`- ${file}`);
    });
  }

  if (options.executionSummary) {
    sections.push('\n## Execution Summary');
    sections.push(options.executionSummary);
  }

  sections.push('\n---');
  sections.push('ðŸ¤– **Generated by [Prompt Dock Bridge](https://github.com/prompt-dock/bridge)**');
  sections.push('*This pull request was automatically generated from an AI agent execution.*');

  return sections.join('\n');
}

async function createGitHubPR(workdir, title, body, branch, baseBranch = 'main') {
  try {
    const { stdout: ghVersion } = await execAsync('gh --version');
    if (!ghVersion) {
      throw new Error('GitHub CLI (gh) not installed');
    }

    const result = await execAsync(
      `gh pr create --title "${title}" --body "${body}" --base ${baseBranch} --head ${branch}`,
      { cwd: workdir }
    );

    const urlMatch = result.stdout.match(/https:\/\/github\.com\/[^\s]+/);
    if (urlMatch) {
      logger.info(`Created GitHub PR: ${urlMatch[0]}`);
      return urlMatch[0];
    }

    return null;
  } catch (error) {
    logger.error('Failed to create GitHub PR:', error);

    try {
      const git = simpleGit(workdir);
      const remotes = await git.getRemotes(true);
      const remoteUrl = remotes[0].refs.fetch || remotes[0].refs.push;
      const repoMatch = remoteUrl.match(/github\.com[:/]([^/]+\/[^.]+)/);

      if (repoMatch) {
        const repoPath = repoMatch[1];
        const prUrl = `https://github.com/${repoPath}/compare/${baseBranch}...${branch}?expand=1`;
        logger.info(`Open this URL to create PR: ${prUrl}`);
        return prUrl;
      }
    } catch (e) {
      logger.error('Failed to generate PR URL:', e);
    }

    throw error;
  }
}

async function createGitLabMR(workdir, title, body, branch, baseBranch = 'main') {
  try {
    const { stdout: glabVersion } = await execAsync('glab --version');
    if (!glabVersion) {
      throw new Error('GitLab CLI (glab) not installed');
    }

    const result = await execAsync(
      `glab mr create --title "${title}" --description "${body}" --target-branch ${baseBranch} --source-branch ${branch}`,
      { cwd: workdir }
    );

    const urlMatch = result.stdout.match(/https:\/\/gitlab\.com\/[^\s]+/);
    if (urlMatch) {
      logger.info(`Created GitLab MR: ${urlMatch[0]}`);
      return urlMatch[0];
    }

    return null;
  } catch (error) {
    logger.error('Failed to create GitLab MR:', error);
    throw error;
  }
}

async function createBitbucketPR(workdir, title, body, branch, baseBranch = 'main') {
  logger.info('Bitbucket PR creation requires manual steps');

  const git = simpleGit(workdir);
  const remotes = await git.getRemotes(true);
  const remoteUrl = remotes[0].refs.fetch || remotes[0].refs.push;
  const repoMatch = remoteUrl.match(/bitbucket\.org[:/]([^/]+\/[^.]+)/);

  if (repoMatch) {
    const repoPath = repoMatch[1];
    const prUrl = `https://bitbucket.org/${repoPath}/pull-requests/new?source=${branch}&dest=${baseBranch}`;
    logger.info(`Open this URL to create PR: ${prUrl}`);
    return prUrl;
  }

  return null;
}